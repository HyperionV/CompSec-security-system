# Security Application - Execution Flows

## Application Initialization Flow

### 1. Startup Sequence

```python
# main.py execution flow
def main():
    # Initialize application
    app = QApplication(sys.argv)

    # Initialize database
    db = DatabaseSQLite()
    db.initialize_database()

    # Create data directories
    create_data_directories()

    # Initialize logging
    logger = SecurityLogger()
    logger.log_event("system_startup", None, "Application started")

    # Run key lifecycle checks
    key_lifecycle = KeyLifecycle(db)
    key_lifecycle.check_expired_keys()

    # Launch GUI
    main_window = MainWindow(db, logger)
    main_window.show()

    sys.exit(app.exec_())
```

### 2. Database Initialization

```python
def initialize_database():
    # Create tables if not exist
    tables = [
        "users", "keys", "otp_codes",
        "activity_logs", "public_keys"
    ]

    for table in tables:
        execute_create_table_sql(table)

    # Create default admin user if none exists
    if not admin_exists():
        create_default_admin()
```

### 3. Directory Structure Creation

```python
def create_data_directories():
    directories = [
        "data/encrypted/",
        "data/decrypted/",
        "data/qr_codes/",
        "data/signatures/",
        "logs/"
    ]

    for directory in directories:
        os.makedirs(directory, exist_ok=True)
```

---

## User Registration Execution Flow

### 1. Registration Process

```python
def register_user(email, name, phone, address, birth_date, passphrase):
    # Step 1: Validation
    validate_email_unique(email)
    validate_passphrase_strength(passphrase)
    validate_required_fields(name, phone, address, birth_date)

    # Step 2: Generate security components
    salt = secrets.token_hex(32)
    password_hash = hashlib.sha256((passphrase + salt).encode()).hexdigest()
    recovery_code = secrets.token_urlsafe(32)
    recovery_salt = secrets.token_hex(32)
    recovery_hash = hashlib.sha256((recovery_code + recovery_salt).encode()).hexdigest()

    # Step 3: Database transaction
    try:
        user_id = db.insert_user(
            email=email,
            name=name,
            phone=phone,
            address=address,
            birth_date=birth_date,
            password_hash=password_hash,
            salt=salt,
            recovery_code_hash=recovery_hash,
            recovery_salt=recovery_salt
        )

        # Step 4: Security logging
        logger.log_event("user_registration", user_id, f"User registered: {email}")

        # Step 5: Display recovery code (one-time)
        display_recovery_code_dialog(recovery_code)

        return {"success": True, "user_id": user_id}

    except Exception as e:
        logger.log_event("user_registration_failed", None, f"Registration failed: {email} - {str(e)}")
        raise RegistrationError(f"Registration failed: {str(e)}")
```

### 2. Password Strength Validation

```python
def validate_passphrase_strength(passphrase):
    requirements = {
        "min_length": len(passphrase) >= 8,
        "has_upper": any(c.isupper() for c in passphrase),
        "has_lower": any(c.islower() for c in passphrase),
        "has_digit": any(c.isdigit() for c in passphrase),
        "has_special": any(c in "!@#$%^&*()_+-=[]{}|;:,.<>?" for c in passphrase)
    }

    failed_requirements = [req for req, met in requirements.items() if not met]

    if failed_requirements:
        raise ValidationError(f"Passphrase requirements not met: {failed_requirements}")

    return True
```

---

## Authentication Execution Flow

### 1. Login Process

```python
def authenticate_user(email, passphrase):
    # Step 1: User lookup and basic validation
    user = db.get_user_by_email(email)
    if not user:
        logger.log_event("login_attempt", None, f"Login failed - user not found: {email}")
        raise AuthenticationError("Invalid credentials")

    # Step 2: Account lockout check
    lockout_status = check_lockout_status(user)
    if lockout_status["locked"]:
        logger.log_event("login_blocked", user.id, f"Login blocked - account locked: {email}")
        raise AccountLockedError(lockout_status["message"])

    # Step 3: Password verification
    password_hash = hashlib.sha256((passphrase + user.salt).encode()).hexdigest()
    if password_hash != user.password_hash:
        record_failed_attempt(user)
        logger.log_event("login_failed", user.id, f"Login failed - invalid password: {email}")
        raise AuthenticationError("Invalid credentials")

    # Step 4: Reset failed attempts on success
    reset_failed_attempts(user)
    logger.log_event("login_success", user.id, f"Login successful: {email}")

    # Step 5: Initiate MFA
    return initiate_mfa_challenge(user)
```

### 2. MFA Challenge Process

```python
def initiate_mfa_challenge(user):
    # Generate OTP
    otp_code = generate_otp_code()
    expiry_time = datetime.now() + timedelta(minutes=5)

    # Store OTP in database
    db.insert_otp_code(
        user_id=user.id,
        code=otp_code,
        expires_at=expiry_time
    )

    # Simulate email sending (display in console)
    simulate_email_delivery(user.email, otp_code)

    logger.log_event("mfa_challenge", user.id, f"MFA challenge sent: {user.email}")

    return {
        "mfa_required": True,
        "user_id": user.id,
        "email": user.email
    }
```

### 3. MFA Verification Process

```python
def verify_mfa_code(user_id, entered_code):
    # Get valid OTP codes for user
    valid_codes = db.get_valid_otp_codes(user_id)

    for otp_record in valid_codes:
        if otp_record.code == entered_code and not otp_record.used:
            # Mark code as used
            db.mark_otp_used(otp_record.id)

            # Create session
            session = create_user_session(user_id)

            logger.log_event("mfa_success", user_id, "MFA verification successful")

            return {
                "success": True,
                "session_id": session.id,
                "user": get_user_by_id(user_id)
            }

    logger.log_event("mfa_failed", user_id, f"MFA verification failed - invalid code: {entered_code}")
    raise MFAError("Invalid or expired MFA code")
```

---

## RSA Key Management Execution Flow

### 1. Key Generation Process

```python
def generate_rsa_key_pair(user_id, passphrase):
    # Step 1: Generate RSA key pair
    private_key = rsa.generate_private_key(
        public_exponent=65537,
        key_size=2048,
        backend=default_backend()
    )
    public_key = private_key.public_key()

    # Step 2: Serialize keys
    private_key_pem = private_key.private_bytes(
        encoding=serialization.Encoding.PEM,
        format=serialization.PrivateFormat.PKCS8,
        encryption_algorithm=serialization.NoEncryption()
    )

    public_key_pem = public_key.public_bytes(
        encoding=serialization.Encoding.PEM,
        format=serialization.PublicFormat.SubjectPublicKeyInfo
    )

    # Step 3: Encrypt private key
    encrypted_private_key = encrypt_private_key_with_passphrase(private_key_pem, passphrase)

    # Step 4: Calculate expiration date
    creation_date = datetime.now()
    expiration_date = creation_date + timedelta(days=90)

    # Step 5: Store in database
    try:
        key_id = db.insert_key(
            user_id=user_id,
            public_key=public_key_pem.decode(),
            encrypted_private_key=encrypted_private_key,
            created_at=creation_date,
            expires_at=expiration_date,
            status="valid"
        )

        logger.log_event("key_generation", user_id, f"RSA key pair generated - ID: {key_id}")

        return {
            "success": True,
            "key_id": key_id,
            "public_key": public_key_pem.decode(),
            "expiration_date": expiration_date
        }

    except Exception as e:
        logger.log_event("key_generation_failed", user_id, f"Key generation failed: {str(e)}")
        raise KeyGenerationError(f"Failed to generate keys: {str(e)}")
```

### 2. Private Key Encryption Process

```python
def encrypt_private_key_with_passphrase(private_key_pem, passphrase):
    # Derive encryption key from passphrase
    salt = secrets.token_bytes(16)
    kdf = PBKDF2HMAC(
        algorithm=hashes.SHA256(),
        length=32,
        salt=salt,
        iterations=100000,
        backend=default_backend()
    )
    encryption_key = kdf.derive(passphrase.encode())

    # Encrypt private key with AES
    iv = secrets.token_bytes(16)
    cipher = Cipher(algorithms.AES(encryption_key), modes.CBC(iv), backend=default_backend())
    encryptor = cipher.encryptor()

    # Pad data to block size
    padded_data = pad_data(private_key_pem)
    encrypted_data = encryptor.update(padded_data) + encryptor.finalize()

    # Combine salt, IV, and encrypted data
    encrypted_package = {
        "salt": base64.b64encode(salt).decode(),
        "iv": base64.b64encode(iv).decode(),
        "encrypted_data": base64.b64encode(encrypted_data).decode(),
        "algorithm": "AES-256-CBC",
        "kdf": "PBKDF2-SHA256",
        "iterations": 100000
    }

    return json.dumps(encrypted_package)
```

### 3. Key Status Monitoring Process

```python
def check_key_lifecycle():
    # Get all active keys
    active_keys = db.get_all_active_keys()

    for key in active_keys:
        current_status = calculate_key_status(key.created_at)

        if current_status != key.status:
            # Update key status
            db.update_key_status(key.id, current_status)

            # Log status change
            logger.log_event("key_status_change", key.user_id,
                            f"Key {key.id} status changed to {current_status}")

            # Send notifications for expiring keys
            if current_status == "expiring_soon":
                send_key_expiration_warning(key.user_id, key.expires_at)

def calculate_key_status(created_at):
    days_since_creation = (datetime.now() - created_at).days

    if days_since_creation >= 90:
        return "expired"
    elif days_since_creation >= 83:
        return "expiring_soon"
    else:
        return "valid"
```

---

## File Encryption Execution Flow

### 1. Encryption Process

```python
def encrypt_file(file_path, recipient_email, output_format="combined"):
    # Step 1: Validate inputs
    if not os.path.exists(file_path):
        raise FileNotFoundError(f"File not found: {file_path}")

    recipient_public_key = get_public_key_by_email(recipient_email)
    if not recipient_public_key:
        raise RecipientError(f"Public key not found for: {recipient_email}")

    # Step 2: Read file data
    with open(file_path, 'rb') as f:
        file_data = f.read()

    file_size = len(file_data)
    logger.log_event("file_encryption_start", current_user.id,
                     f"Starting encryption of {os.path.basename(file_path)} ({file_size} bytes)")

    # Step 3: Choose processing method based on file size
    if file_size > 5 * 1024 * 1024:  # 5MB threshold
        return encrypt_large_file(file_path, file_data, recipient_public_key, output_format)
    else:
        return encrypt_standard_file(file_path, file_data, recipient_public_key, output_format)
```

### 2. Standard File Encryption

```python
def encrypt_standard_file(file_path, file_data, recipient_public_key, output_format):
    # Step 1: Generate session key and IV
    session_key = secrets.token_bytes(32)  # 256-bit AES key
    iv = secrets.token_bytes(16)  # 128-bit IV for GCM

    # Step 2: Encrypt file data with AES-GCM
    cipher = Cipher(algorithms.AES(session_key), modes.GCM(iv), backend=default_backend())
    encryptor = cipher.encryptor()
    encrypted_data = encryptor.update(file_data) + encryptor.finalize()
    authentication_tag = encryptor.tag

    # Step 3: Encrypt session key with recipient's RSA public key
    encrypted_session_key = recipient_public_key.encrypt(
        session_key,
        padding.OAEP(
            mgf=padding.MGF1(algorithm=hashes.SHA256()),
            algorithm=hashes.SHA256(),
            label=None
        )
    )

    # Step 4: Create metadata
    metadata = {
        "sender": current_user.email,
        "filename": os.path.basename(file_path),
        "timestamp": datetime.now().isoformat(),
        "file_size": len(file_data),
        "encryption_method": "AES-256-GCM",
        "key_exchange": "RSA-OAEP"
    }

    # Step 5: Package encrypted data
    if output_format == "combined":
        output_file = create_combined_encrypted_file(
            encrypted_data, authentication_tag, iv,
            encrypted_session_key, metadata
        )
    else:
        output_file = create_separate_encrypted_files(
            encrypted_data, authentication_tag, iv,
            encrypted_session_key, metadata
        )

    logger.log_event("file_encryption_complete", current_user.id,
                     f"Encrypted {metadata['filename']} for {recipient_email}")

    return output_file
```

### 3. Large File Block Processing

```python
def encrypt_large_file(file_path, file_data, recipient_public_key, output_format):
    BLOCK_SIZE = 1024 * 1024  # 1MB blocks
    session_key = secrets.token_bytes(32)
    blocks = []

    # Process file in blocks
    for i in range(0, len(file_data), BLOCK_SIZE):
        block_data = file_data[i:i+BLOCK_SIZE]
        block_index = i // BLOCK_SIZE

        # Encrypt each block with unique IV
        iv = secrets.token_bytes(16)
        cipher = Cipher(algorithms.AES(session_key), modes.GCM(iv), backend=default_backend())
        encryptor = cipher.encryptor()
        encrypted_block = encryptor.update(block_data) + encryptor.finalize()
        auth_tag = encryptor.tag

        blocks.append({
            "index": block_index,
            "iv": base64.b64encode(iv).decode(),
            "data": base64.b64encode(encrypted_block).decode(),
            "auth_tag": base64.b64encode(auth_tag).decode(),
            "hash": hashlib.sha256(block_data).hexdigest()
        })

        # Update progress
        progress = ((block_index + 1) * BLOCK_SIZE) / len(file_data) * 100
        update_encryption_progress(min(progress, 100))

    # Encrypt session key
    encrypted_session_key = recipient_public_key.encrypt(session_key, padding.OAEP(...))

    # Create metadata
    metadata = {
        "sender": current_user.email,
        "filename": os.path.basename(file_path),
        "timestamp": datetime.now().isoformat(),
        "file_size": len(file_data),
        "total_blocks": len(blocks),
        "block_size": BLOCK_SIZE,
        "processing_mode": "large_file",
        "encryption_method": "AES-256-GCM-Blocks"
    }

    return create_encrypted_package(blocks, encrypted_session_key, metadata, output_format)
```

---

## File Decryption Execution Flow

### 1. Decryption Process

```python
def decrypt_file(encrypted_file_path, passphrase):
    # Step 1: Detect file format
    file_format = detect_encryption_format(encrypted_file_path)

    # Step 2: Parse encrypted data
    if file_format == "combined":
        encrypted_data, encrypted_key, metadata = parse_combined_file(encrypted_file_path)
    elif file_format == "separate":
        encrypted_data = load_encrypted_file(encrypted_file_path)
        encrypted_key, metadata = load_key_file(encrypted_file_path.replace('.enc', '.key'))
    else:
        raise DecryptionError("Unknown file format")

    # Step 3: Decrypt private key
    private_key = decrypt_private_key_with_passphrase(current_user.encrypted_private_key, passphrase)

    # Step 4: Decrypt session key
    try:
        session_key = private_key.decrypt(
            encrypted_key,
            padding.OAEP(
                mgf=padding.MGF1(algorithm=hashes.SHA256()),
                algorithm=hashes.SHA256(),
                label=None
            )
        )
    except Exception as e:
        logger.log_event("decryption_failed", current_user.id,
                        f"Session key decryption failed: {str(e)}")
        raise DecryptionError("Failed to decrypt session key - invalid private key or file corruption")

    # Step 5: Decrypt file content
    if metadata.get("processing_mode") == "large_file":
        decrypted_data = decrypt_large_file_blocks(encrypted_data, session_key, metadata)
    else:
        decrypted_data = decrypt_standard_file(encrypted_data, session_key, metadata)

    # Step 6: Save decrypted file
    output_path = save_decrypted_file(decrypted_data, metadata)

    logger.log_event("file_decryption_complete", current_user.id,
                     f"Decrypted {metadata['filename']} from {metadata['sender']}")

    return {
        "success": True,
        "output_path": output_path,
        "metadata": metadata
    }
```

### 2. Large File Block Decryption

```python
def decrypt_large_file_blocks(block_data, session_key, metadata):
    total_blocks = metadata["total_blocks"]
    decrypted_blocks = [None] * total_blocks

    for block_info in block_data:
        block_index = block_info["index"]
        iv = base64.b64decode(block_info["iv"])
        encrypted_block_data = base64.b64decode(block_info["data"])
        auth_tag = base64.b64decode(block_info["auth_tag"])

        # Decrypt block
        cipher = Cipher(algorithms.AES(session_key), modes.GCM(iv, auth_tag), backend=default_backend())
        decryptor = cipher.decryptor()
        decrypted_block = decryptor.update(encrypted_block_data) + decryptor.finalize()

        # Verify block integrity
        block_hash = hashlib.sha256(decrypted_block).hexdigest()
        if block_hash != block_info["hash"]:
            raise DecryptionError(f"Block {block_index} integrity check failed")

        decrypted_blocks[block_index] = decrypted_block

        # Update progress
        progress = (block_index + 1) / total_blocks * 100
        update_decryption_progress(progress)

    # Reassemble file
    return b''.join(decrypted_blocks)
```

---

## Digital Signature Execution Flow

### 1. File Signing Process

```python
def sign_file(file_path, passphrase):
    # Step 1: Validate file exists
    if not os.path.exists(file_path):
        raise FileNotFoundError(f"File not found: {file_path}")

    # Step 2: Read and hash file
    with open(file_path, 'rb') as f:
        file_data = f.read()

    file_hash = hashlib.sha256(file_data).digest()

    # Step 3: Decrypt private key
    private_key = decrypt_private_key_with_passphrase(current_user.encrypted_private_key, passphrase)

    # Step 4: Sign file hash
    try:
        signature = private_key.sign(
            file_hash,
            padding.PSS(
                mgf=padding.MGF1(hashes.SHA256()),
                salt_length=padding.PSS.MAX_LENGTH
            ),
            hashes.SHA256()
        )
    except Exception as e:
        logger.log_event("signing_failed", current_user.id, f"File signing failed: {str(e)}")
        raise SigningError(f"Failed to sign file: {str(e)}")

    # Step 5: Create signature metadata
    signature_data = {
        "signature": base64.b64encode(signature).decode(),
        "signer_email": current_user.email,
        "signer_name": current_user.name,
        "file_name": os.path.basename(file_path),
        "file_size": len(file_data),
        "file_hash": hashlib.sha256(file_data).hexdigest(),
        "timestamp": datetime.now().isoformat(),
        "hash_algorithm": "SHA-256",
        "signature_algorithm": "RSA-PSS",
        "key_id": current_user.current_key_id
    }

    # Step 6: Save signature file
    signature_file_path = file_path + '.sig'
    with open(signature_file_path, 'w') as f:
        json.dump(signature_data, f, indent=2)

    logger.log_event("file_signed", current_user.id,
                     f"Signed file: {os.path.basename(file_path)}")

    return {
        "success": True,
        "signature_file": signature_file_path,
        "signature_data": signature_data
    }
```

### 2. Signature Verification Process

```python
def verify_signature(file_path, signature_file_path):
    # Step 1: Load signature data
    try:
        with open(signature_file_path, 'r') as f:
            signature_data = json.load(f)
    except Exception as e:
        raise VerificationError(f"Failed to load signature file: {str(e)}")

    # Step 2: Calculate current file hash
    with open(file_path, 'rb') as f:
        current_file_data = f.read()
    current_hash = hashlib.sha256(current_file_data).digest()

    # Step 3: Check file integrity (optional)
    stored_hash = signature_data.get("file_hash")
    if stored_hash:
        current_hash_hex = hashlib.sha256(current_file_data).hexdigest()
        if current_hash_hex != stored_hash:
            logger.log_event("verification_warning", current_user.id,
                           f"File hash mismatch - file may have been modified: {file_path}")

    # Step 4: Get signer's public keys
    signer_email = signature_data["signer_email"]
    public_keys = get_public_keys_by_email(signer_email)

    if not public_keys:
        return {
            "valid": False,
            "reason": "unknown_signer",
            "message": f"No public key found for signer: {signer_email}"
        }

    # Step 5: Attempt verification with each public key
    signature_bytes = base64.b64decode(signature_data["signature"])

    for public_key_data in public_keys:
        try:
            public_key = load_public_key_from_pem(public_key_data.public_key)

            public_key.verify(
                signature_bytes,
                current_hash,
                padding.PSS(
                    mgf=padding.MGF1(hashes.SHA256()),
                    salt_length=padding.PSS.MAX_LENGTH
                ),
                hashes.SHA256()
            )

            # Verification successful
            logger.log_event("signature_verified", current_user.id,
                           f"Signature verified for {file_path} by {signer_email}")

            return {
                "valid": True,
                "signer_email": signer_email,
                "signer_name": signature_data.get("signer_name"),
                "timestamp": signature_data["timestamp"],
                "file_name": signature_data["file_name"]
            }

        except InvalidSignature:
            continue
        except Exception as e:
            logger.log_event("verification_error", current_user.id,
                           f"Verification error: {str(e)}")
            continue

    # No valid signature found
    logger.log_event("signature_invalid", current_user.id,
                     f"Invalid signature for {file_path}")

    return {
        "valid": False,
        "reason": "invalid_signature",
        "message": "Signature verification failed - file may be tampered or signature corrupted"
    }
```

---

## QR Code Operations Execution Flow

### 1. QR Code Generation Process

```python
def generate_qr_code_for_public_key():
    # Step 1: Get user's current public key
    user_key = get_user_current_key(current_user.id)
    if not user_key:
        raise QRError("No public key available for QR generation")

    # Step 2: Prepare QR data
    qr_data = {
        "version": "1.0",
        "email": current_user.email,
        "name": current_user.name,
        "created_at": user_key.created_at.isoformat(),
        "expires_at": user_key.expires_at.isoformat(),
        "public_key": base64.b64encode(user_key.public_key.encode()).decode(),
        "key_algorithm": "RSA-2048"
    }

    # Step 3: Create QR code
    qr_json = json.dumps(qr_data, separators=(',', ':'))  # Compact format

    qr = qrcode.QRCode(
        version=1,
        error_correction=qrcode.constants.ERROR_CORRECT_L,
        box_size=10,
        border=4,
    )
    qr.add_data(qr_json)
    qr.make(fit=True)

    # Step 4: Create QR image
    qr_image = qr.make_image(fill_color="black", back_color="white")

    # Step 5: Save QR code file
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    filename = f"{current_user.email}_{timestamp}.png"
    file_path = os.path.join("data/qr_codes", filename)

    qr_image.save(file_path)

    # Step 6: Update database with QR file path
    db.update_public_key_qr_path(user_key.id, file_path)

    logger.log_event("qr_generated", current_user.id, f"QR code generated: {filename}")

    return {
        "success": True,
        "file_path": file_path,
        "qr_data": qr_data
    }
```

### 2. QR Code Import Process

```python
def import_public_key_from_qr(qr_image_path):
    # Step 1: Decode QR code
    try:
        from pyzbar import pyzbar
        from PIL import Image

        image = Image.open(qr_image_path)
        decoded_objects = pyzbar.decode(image)

        if not decoded_objects:
            raise QRError("No QR code found in image")

        qr_data_json = decoded_objects[0].data.decode('utf-8')
        qr_data = json.loads(qr_data_json)

    except Exception as e:
        raise QRError(f"Failed to decode QR code: {str(e)}")

    # Step 2: Validate QR data structure
    required_fields = ["email", "public_key", "created_at"]
    for field in required_fields:
        if field not in qr_data:
            raise QRError(f"Invalid QR code - missing field: {field}")

    # Step 3: Decode and validate public key
    try:
        public_key_pem = base64.b64decode(qr_data["public_key"]).decode()
        public_key = load_public_key_from_pem(public_key_pem)
    except Exception as e:
        raise QRError(f"Invalid public key in QR code: {str(e)}")

    # Step 4: Check if key already exists
    existing_key = db.get_public_key_by_email_and_date(
        qr_data["email"],
        qr_data["created_at"]
    )

    if existing_key:
        return {
            "success": True,
            "message": "Public key already imported",
            "existing": True
        }

    # Step 5: Import public key
    try:
        key_id = db.insert_public_key(
            owner_email=qr_data["email"],
            public_key=public_key_pem,
            created_at=datetime.fromisoformat(qr_data["created_at"]),
            imported_by=current_user.id,
            qr_code_path=qr_image_path
        )

        logger.log_event("public_key_imported", current_user.id,
                        f"Imported public key from QR: {qr_data['email']}")

        return {
            "success": True,
            "key_id": key_id,
            "owner_email": qr_data["email"],
            "owner_name": qr_data.get("name", "Unknown"),
            "created_at": qr_data["created_at"]
        }

    except Exception as e:
        logger.log_event("public_key_import_failed", current_user.id,
                        f"Failed to import public key: {str(e)}")
        raise QRError(f"Failed to import public key: {str(e)}")
```

---

## Security Logging Execution Flow

### 1. Activity Logging Process

```python
def log_security_event(action, user_id, details, status="success"):
    # Step 1: Prepare log entry
    log_entry = {
        "timestamp": datetime.now().isoformat(),
        "user_id": user_id,
        "action": action,
        "details": details,
        "ip_address": get_client_ip_address(),
        "session_id": get_current_session_id(),
        "status": status
    }

    # Step 2: Database logging
    try:
        db.insert_activity_log(
            user_id=user_id,
            action=action,
            details=details,
            ip_address=log_entry["ip_address"],
            timestamp=datetime.now(),
            status=status
        )
    except Exception as e:
        # Fallback to file logging if database fails
        file_log_security_event(log_entry, e)

    # Step 3: File logging (always)
    log_line = format_log_entry(log_entry)

    with open("logs/security.log", "a") as log_file:
        log_file.write(log_line + "\n")

    # Step 4: Real-time monitoring alerts
    if is_security_alert_event(action, status):
        trigger_security_alert(log_entry)

def format_log_entry(entry):
    return (f"[{entry['timestamp']}] "
            f"USER:{entry['user_id']} "
            f"ACTION:{entry['action']} "
            f"STATUS:{entry['status']} "
            f"IP:{entry['ip_address']} "
            f"DETAILS:{entry['details']}")
```

### 2. Failed Login Tracking

```python
def record_failed_login_attempt(email, reason):
    user = db.get_user_by_email(email)
    user_id = user.id if user else None

    # Log the failed attempt
    log_security_event("login_failed", user_id, f"Failed login for {email}: {reason}", "failure")

    if user:
        # Increment failed attempt counter
        user.failed_attempts += 1

        # Check if lockout threshold reached
        if user.failed_attempts >= MAX_FAILED_ATTEMPTS:
            user.is_locked = True
            user.lock_until = datetime.now() + timedelta(seconds=LOCKOUT_DURATION)

            log_security_event("account_locked", user.id,
                             f"Account locked after {MAX_FAILED_ATTEMPTS} failed attempts", "security")

        db.update_user(user)
```

### 3. Admin Activity Monitoring

```python
def log_admin_action(admin_user_id, action, target_user_id, details):
    # Enhanced logging for admin actions
    admin_user = db.get_user_by_id(admin_user_id)
    target_user = db.get_user_by_id(target_user_id) if target_user_id else None

    log_details = {
        "admin_email": admin_user.email,
        "target_email": target_user.email if target_user else "system",
        "action_details": details,
        "timestamp": datetime.now().isoformat()
    }

    log_security_event(f"admin_{action}", admin_user_id,
                       json.dumps(log_details), "success")

    # Special alerting for sensitive admin actions
    sensitive_actions = ["user_role_change", "account_unlock", "system_config_change"]
    if action in sensitive_actions:
        send_admin_action_alert(log_details)
```

This comprehensive documentation provides the complete execution flows and technical implementation details for all 17 features of the Security Application. Each flow includes error handling, security logging, and proper state management to ensure robust and secure operation.
description:
globs:
alwaysApply: false

---
